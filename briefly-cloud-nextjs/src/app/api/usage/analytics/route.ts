/**
 * Usage Analytics API Route
 * 
 * This endpoint provides detailed usage analytics and insights
 * for users and administrators.
 */

import { NextRequest, NextResponse } from 'next/server'
import { withAuth } from '@/app/lib/auth/auth-middleware'
import { withApiControls } from '@/app/lib/usage/usage-middleware'
import { getUsageTracker } from '@/app/lib/usage/usage-tracker'
import { getTierManager } from '@/app/lib/usage/tier-manager'
import { supabaseAdmin } from '@/app/lib/supabase'
import { logger } from '@/app/lib/logger'
import { createError } from '@/app/lib/api-errors'

/**
 * GET /api/usage/analytics
 * 
 * Get usage analytics for the authenticated user
 */
export const GET = withAuth(
  withApiControls(async (request: NextRequest, context) => {
    try {
      const { user } = context
      const { searchParams } = new URL(request.url)\n      const period = searchParams.get('period') as 'current' | 'previous' || 'current'\n      const days = parseInt(searchParams.get('days') || '30')\n      \n      const usageTracker = getUsageTracker()\n      const tierManager = getTierManager()\n      \n      // Get comprehensive analytics\n      const [usageStats, subscription, upgradeRecommendations] = await Promise.all([\n        usageTracker.getUsageStats(user.id, period),\n        tierManager.getUserSubscription(user.id),\n        tierManager.getUpgradeRecommendations(user.id)\n      ])\n      \n      // Calculate usage trends\n      const currentStats = await usageTracker.getUsageStats(user.id, 'current')\n      const previousStats = await usageTracker.getUsageStats(user.id, 'previous')\n      \n      const trends = {\n        chatMessages: {\n          current: currentStats.actionBreakdown.chat || 0,\n          previous: previousStats.actionBreakdown.chat || 0,\n          change: ((currentStats.actionBreakdown.chat || 0) - (previousStats.actionBreakdown.chat || 0)),\n          percentChange: previousStats.actionBreakdown.chat > 0 \n            ? (((currentStats.actionBreakdown.chat || 0) - (previousStats.actionBreakdown.chat || 0)) / (previousStats.actionBreakdown.chat || 0)) * 100\n            : 0\n        },\n        uploads: {\n          current: currentStats.actionBreakdown.upload || 0,\n          previous: previousStats.actionBreakdown.upload || 0,\n          change: ((currentStats.actionBreakdown.upload || 0) - (previousStats.actionBreakdown.upload || 0)),\n          percentChange: previousStats.actionBreakdown.upload > 0 \n            ? (((currentStats.actionBreakdown.upload || 0) - (previousStats.actionBreakdown.upload || 0)) / (previousStats.actionBreakdown.upload || 0)) * 100\n            : 0\n        },\n        apiCalls: {\n          current: currentStats.actionBreakdown.api_call || 0,\n          previous: previousStats.actionBreakdown.api_call || 0,\n          change: ((currentStats.actionBreakdown.api_call || 0) - (previousStats.actionBreakdown.api_call || 0)),\n          percentChange: previousStats.actionBreakdown.api_call > 0 \n            ? (((currentStats.actionBreakdown.api_call || 0) - (previousStats.actionBreakdown.api_call || 0)) / (previousStats.actionBreakdown.api_call || 0)) * 100\n            : 0\n        }\n      }\n      \n      // Calculate efficiency metrics\n      const efficiency = {\n        averageSessionLength: Math.random() * 30 + 10, // Simulate - would calculate from actual data\n        documentsPerSession: Math.random() * 3 + 1,\n        queriesPerDocument: Math.random() * 5 + 2,\n        successRate: Math.random() * 20 + 80 // 80-100%\n      }\n      \n      // Get recent activity\n      const { data: recentActivity } = await supabaseAdmin\n        .from('app.usage_logs')\n        .select('action, created_at, quantity, metadata')\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false })\n        .limit(20)\n      \n      const response = {\n        success: true,\n        data: {\n          userId: user.id,\n          period: {\n            type: period,\n            days,\n            start: usageStats.periodStart,\n            end: usageStats.periodEnd\n          },\n          subscription,\n          currentUsage: usageStats,\n          trends,\n          efficiency,\n          recommendations: upgradeRecommendations,\n          recentActivity: recentActivity?.map(activity => ({\n            action: activity.action,\n            timestamp: activity.created_at,\n            quantity: activity.quantity,\n            details: activity.metadata\n          })) || [],\n          insights: {\n            mostUsedFeature: Object.entries(usageStats.actionBreakdown)\n              .sort(([,a], [,b]) => b - a)[0]?.[0] || 'none',\n            peakUsageDay: 'Monday', // Would calculate from actual data\n            averageDailyUsage: Math.round(usageStats.totalActions / days),\n            projectedMonthlyUsage: Math.round((usageStats.totalActions / days) * 30)\n          },\n          timestamp: new Date().toISOString()\n        }\n      }\n      \n      return NextResponse.json(response)\n      \n    } catch (error) {\n      logger.error('Failed to get usage analytics', {\n        userId: context.user.id,\n        error: (error as Error).message\n      })\n      \n      return NextResponse.json(\n        { \n          success: false, \n          error: 'Failed to get analytics',\n          message: 'Please try again later'\n        },\n        { status: 500 }\n      )\n    }\n  })\n)\n\n/**\n * GET /api/usage/analytics/export\n * \n * Export usage data for billing integration\n */\nexport const POST = withAuth(\n  withApiControls(async (request: NextRequest, context) => {\n    try {\n      const { user } = context\n      const body = await request.json()\n      const { format = 'json', startDate, endDate } = body\n      \n      if (!startDate || !endDate) {\n        return NextResponse.json(\n          { \n            success: false, \n            error: 'Date range required',\n            message: 'Please provide startDate and endDate'\n          },\n          { status: 400 }\n        )\n      }\n      \n      // Get detailed usage logs for the period\n      const { data: usageLogs, error } = await supabaseAdmin\n        .from('app.usage_logs')\n        .select('*')\n        .eq('user_id', user.id)\n        .gte('created_at', startDate)\n        .lte('created_at', endDate)\n        .order('created_at', { ascending: true })\n      \n      if (error) {\n        throw error\n      }\n      \n      const exportData = {\n        userId: user.id,\n        userEmail: user.email,\n        exportPeriod: {\n          start: startDate,\n          end: endDate\n        },\n        totalRecords: usageLogs?.length || 0,\n        summary: {\n          totalActions: usageLogs?.reduce((sum, log) => sum + (log.quantity || 1), 0) || 0,\n          actionBreakdown: usageLogs?.reduce((acc, log) => {\n            acc[log.action] = (acc[log.action] || 0) + (log.quantity || 1)\n            return acc\n          }, {} as Record<string, number>) || {},\n          dailyBreakdown: {} // Would calculate daily usage\n        },\n        detailedLogs: format === 'detailed' ? usageLogs : undefined,\n        exportedAt: new Date().toISOString(),\n        exportId: `export_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n      }\n      \n      // Log the export\n      logger.info('Usage data exported', {\n        userId: user.id,\n        exportId: exportData.exportId,\n        recordCount: exportData.totalRecords,\n        format\n      })\n      \n      return NextResponse.json({\n        success: true,\n        data: exportData\n      })\n      \n    } catch (error) {\n      logger.error('Failed to export usage data', {\n        userId: context.user.id,\n        error: (error as Error).message\n      })\n      \n      return NextResponse.json(\n        { \n          success: false, \n          error: 'Failed to export data',\n          message: 'Please try again later'\n        },\n        { status: 500 }\n      )\n    }\n  })\n)